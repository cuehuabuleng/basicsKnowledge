 ## http

 ### 三次握手：
这个连接必须是一方主动打开另外一方被动打开，客户端结束close阶段，服务端业也结束close阶段，进入LISTEN阶段
    1、客户端主动发送请求与服务端建立连接的TCP报文，告诉服务端想要建立连接 SYN=1， seq = x，之后客户端马上进入SYN-SENT阶段；
   
    2、服务端收到客户端的请求建立连接的的TCP报文之后，结束LISTEN阶段，并且向客户端发送一段TCP报文 标记位：seq=y，ACK=1，确认 位：Ack=x+1，告诉客户端同意进行连接，并且马上进入SYN-RCVD阶段
    
    3、客户端接到服务端返回来的报文后，知道了服务端同意进行连接，随后向服务端发送最后一段TCP报文，告诉服务端已经接收到了确认信息，然后进入到连接阶段，服务端接收到了客户端最后的TCP报文信息之后，明确了从服务端到客户端的数据传输是正常的，然后就进入连接阶段 ESTABLISHED。就可以开始数据的传输了。

    至此，三次握手完成。
    在客户端与服务端的TCP报文传输的过程中，双方的确认号和Ack和序号seq都是在彼此的Ack和seq的基础上面计算的，这样就可以保证三次握手的连贯性。一旦出现报文丢失，就无法进行继续握手，以此来确保三次握手的顺利完成。

    为什么三次握手：
    1、防止已经失效的客户端信息再次被服务端接受，造成错误
    2、防止服务端开启一些无用的连接，造成服务端眼里过大，以及资源浪费。

 

 ###  四次挥手
    四次挥是指的是TCP连接的释放。连接的释放是由一方主动释放，另外一放被动释放。
    1、客户端想服务端发送一段tcp报文，标记号：FIN=1、序号：seq=u，告诉服务端想要释放连接，然后从建立连接的状态进入到第一个等待阶段；
    2、服务端接收到客户端的释放连接的TCP报文之后，确认了客户端想要释放连接，然后从建立连接阶段进如半关闭阶段，然后想客户端发送一段TCP报文：序号swq=1：标记号ACK=1 FIN=1,，确认号：Ack=ui+1；  告诉客户端已经接收到了请求释放连接的信号
    3、客户端收到了服务端的TCP确认报文之后，就结束等待的第一阶段，进入第二阶段。    当服务端已经准备好了释放连接时，就再次向客户端发送TCP报文，告诉客户端自己已经准备好了释放连接了，然后进入了最后的确认等待阶段。
    4、客户端接收到来自服务端的tcp报文后，就马上服务端返一段确认收到服务端信息的报文，告诉服务端已经收到了报文，然后进入时间等待阶段 time-wait阶段。
    5、服务端在接收到客户端的报文之后，就结束了最后的确认阶段，进入close阶段，这是服务端到客户端的连接已经关闭。
    6、然后客户端在等待了2msl之后，如果没有再收到服务端的报文，就结束等待，进入close阶段，四次挥手结束。

        这里客户端最后需要等待2msl是因为。客户端需要确认服务端是否收到了自己的确认报文，因为如果服务端妹有收到自己的确认报文，再等待了1msl之后，会重新向客户端发送已经很准备好释放连接的报文。这里的msl是指一段报文再客户端和服务端之间传输的最大生命周期。而2msl是指服务端发出准备释放连接的FIN报文和客户端发出ACK确认报文所能保持的最大时长。
            所以，如果客户端再最后的时间等待阶段，2msl之内妹有再次收到服务端的报文，那么就可以确认服务端已经收到了自己的Ack确认报文，然后就结束等待进入close阶段，关闭连接，四次挥手到此结束。


## https

### 三次握手
   

HTTPS确切的的说不是一种协议，而是HTTP + SSL (TSL)的结合体。HTTP报文经过SSL层加密后交付给TCP层进行传输。SSL(安全套接层)主要采取的是RSA（非对称加密）与AES（对称加密）结合的加密方式。先通过RSA交换AES的密钥，然后通过AES进行报文加密和解密

所以https的三次握手和http差不多，就是需要在tcp三次握手之后，还有一个ssl握手的过程(即身份的认证和秘钥协商的过程)

ssl的握手过程：




https中使用的对称加密算法和密钥是客户端发送给服务器的，不能反着来，首先这里要明确对称加密算法使用的秘钥和加密算法都是保密的，而非对称加密算法使用的公钥和加解密算法是公开的，私钥是保密的，如果说是对称加密算法由服务器发送给客户端将会产生什么后果呢？所有持有公钥的客户端都可以拿到对称加密算法的秘钥；如果有客户端发送给服务器就不同了，客户端使用公钥加密后，只有私钥能解密，即使第三方劫持到也无法解密

<!-- https://zhuanlan.zhihu.com/p/86426969 -->