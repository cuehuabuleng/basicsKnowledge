一、网络请求优化

    1、静态资源
        （1）、拼接、合并、压缩、制作雪碧图。   由于http的限制，在建立一个tcp请求的时候，需要一些耗时， 所以，我们对资源进行合并、压缩，目的就是要减少请求数和减少包的体积，加快传输速度。
            ## 对css，js，图片使用webpack等打包工具进行打包压缩、合并、去重。在这基础上，需要根据指自身的业务，合理地对公共代码，公共库，和首屏的代码进行单独的打包压缩，实现按需加载。
            ## 对于图片资源，我们可以制作雪碧图。将页面上的一些小的icon都合并到一张大的图片上面，使用css背景定位来实现使用不同的icon。这样就可以明显地减少http请求的次数了。
        （2）、CDN资源分发
            将一些静态的资源放在第三方的CDN服务器上面，一方面可以有效的减少自己服务器的压力。另外一方面CDN能够根据网络流量，各个节点的连接、负载等状况，将用户的请求导向离用户最近的服务节点上面，保证资源的加载速度和稳定性。

        （3）、缓存。 这里的缓存有很多方面，如有NDS解析缓存，代理服务器缓存，还有客户端的缓存。这里重点讲前端的缓存
                a、 浏览器的本地缓存： localStorage，sessionStorage，cookie
                b、http缓存： 强制缓存： Expires  到期的时间点(单位：分钟)     cache-control（http1.1） （单位：秒）有效时长
                              协商缓存： last-modified/if-lastmodified-since服务端资源最后的修改时间    Etag/if-None-match  一段由服务端资源的内容的hash标识

        （4）、资源分片。将资源分别存在不同的服务器主机上面，这样做的目的就是为突破浏览器对一台主机简历tcp连接的数量限制。 浏览器对一台主机只能简历6-8个的tcp连接，所以将资源储存在不同的主机上面，可以建立更多的tcp连接，降低请求耗时，加快资源的加载速度。

    2、业务数据
        （1）、接口合并。为了解决一个功能需要多次调用后端的多个接口的问题。可以使用node或者其他的语言来是实现一个代理中间层，来实现前端的接口合并。前端只需要按照约定来向向代理服务器发起一次的请求，由代理服务器向接口服务器发送多次的请求，得到最后的数据之后返回给前端。  这样做就可以减少前端的请求次数，而且代理服务器可以脱离http的限制，使用更加高效的协议来进行通讯。

        
        

二、页面渲染优化

    1、阻止阻塞渲染。 主要针对 css和js。因为css会阻塞页面的渲染，js会阻塞html的解析和渲染。
                     将css放在首部，提前将样式表加载出来。方式出现闪屏现象（就是dom结构已经加载出来了，但是css样式还没有加载，后面才加载出来，页面就会进行重绘，出现闪屏现象。）
                     将js放在底部防止阻塞页面解析。  使用defer和async来进行异步加载。

    2、减少重绘和回流
                    大多数浏览器其实自带优化： 通过队列化修改并批量执行来优化重排过程。即先将导致重排和重绘的操作先压入到一个队列中，达到一定数量后再一起处理，达到减少重排和重绘的目的。当你获取布局信息的操作的时候，会强制队列刷新. 因为这些属性，都是需要实时回馈给用户的几何属性或者是布局属性，当然不能再依靠浏览器的优化，因此浏览器不得不立即执行渲染队列中的“待处理变化”，触发重排返回正确的值。

                    ## js尽量少操作dom和css属性 
                    ## 为产生动画的html元素使用position的fixed和absolute(脱离了文档流)，那么修改他们的css属性就不会引起回流了。
                    ## 将DOM离线之后再操作，设置display：none，脱离文档流之后，再修改属性。
                    ## 使用trasform来进行元素的位移和形变。因为transform会触发GPU硬件加速，使用的是独立图层，然后由独立的合成器进行处理，不会造成回流。
                    ## 使用文档片段创建一个子树，然后再拷贝到文档中， document.careateDocumentFragment()

    3、提高代码质量
                    html： ## deom的层级不要太深，会增加dom树的构建时间，js访问深层的dom也会造成更大的负担。        meta标签里面定义文档的编码，便于浏览器解析。
                    css：减少css嵌套层级和选择适当的选择器。     对于首屏关键的css可以使用style内联
                    js： ## 对需要访问的dom节点进行缓存，避免重复去访问。
                         ## 减少直接通过js来修改样式，使用修改class名来修改样式
                         ## 对于比较频繁的回调，使用防抖节流来控制频率
                         ## 计时器和定时器使用完之后需要及时销毁
                         ## 复杂的计算js代码可以放在worker进程中运行。
 
https://segmentfault.com/a/1190000016458627?utm_source=sf-related