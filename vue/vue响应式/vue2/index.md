vue的响应式原理
当修改vue中的数据时，视图就会进行更新。

需要做到这一点，vue需要做这样的事情：
    监听数据的变化
    收集视图依赖了那些数据
    当数据变化的时候，通知需要更新的试图进行更新
专业点就是：
    数据劫持/代理
    收集依赖
    发布订阅模式

一、如何实现数据劫持，对数据进行监听和追踪：
    方法一： 通过Object.defineProperty(vue2x),进行数据的劫持或者代理。这里讲defineProperty。
             Vue通过Object.defineProperty来设顶对象的getter/setter方法来监听数据的变化，通过getter方法方法收集依赖，而每一个setter方法就是一个观察者。在数据发生改变的时候，负责通知订阅者更新视图。
    这个方法有缺点：1、无法检测到对象属性的新增和删除
                      原因：getter/setter方法只能追踪一个数据是否被修改，无法追踪属性被删除和新增。
                      解决：  1、可以通过Vue.set()方法来对对象的属性进行新增或者修改，就可以是实现监听了。
                             2、给这个对象重新赋值。
                   2、无法监听数组的改变
                     原因：Object.defineProperty是可以监听数组下标的变化的，只是vue的源码实现中，从性能/体验的性价比的考虑
                          上面，放弃了这个特性。
                     解决： vue的源码中，对数组的一些方法进行了重写，有 push,pop,shift, unshift,sort,reverse, splice，使
                            用这些方法对数组进行操作的话就可以实现响应。
                        
    方法二：es6的Proxy(v3.0)，这里就是vue3和vue的响应式部分不一样的地方
            Proxy是Javascript 2015的一个新特征。proxy代理的是整个对象，和Object.defineProperty不一样，需要遍历对象的每个属性，Proxy只需要做一层代理就可以监听同级结构下的属性变化，当然对于深层结构，还是需要进行递归。这里Proxy是可以对数组的变化进行监听的。
            Proxy的兼容性不太好。

二、收集依赖：这里核心思想就是“事件发布订阅模式”
    这里需要讲到两个东西：
    Dep-订阅者
        创建一个Dep，使用这个Dep来收集依赖以及派发更新操作，主要的作用就是用来存放观察者Watcher。然后有数据变动的时候，就通知Watcher。
    Watcher-观察者
        一旦有数据发生改变的时候，他就会被Dep通知，然后Watcher就会通知其他的地方。当数据发生改变的时候，可能很多地方都用到了这个数据，而且类型还可能不一样，可能是模板，也可能是用户自己写的watcher，所以需要抽离出一个专门处理这些情况的类。然后收集的时候就将他收集进来，通知的话就通知他，由他去通知其他地方。

        所谓的依赖，其实就是Watcher。至于如何收集依赖，总结起来就一句话，在getter中收集依赖，在setter中触发依赖。先收集依赖，即把用到该数据的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就行了。

        具体来说，当外界通过Watcher读取数据时，便会触发getter从而将Watcher添加到依赖中，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。




附加：
首先是观察者，observer他利用obj defineproperty去拿到data依赖，然后遍历子集依赖，getter拿到所有子依赖，就告诉订阅者，warcher，每收集一个子依赖就new一个订阅者，最后订阅者被收集起来，dep就是个收集器，是个集合或者数组。然后通过编译器compile去拿组件里所有我们定义的temeplate dom这里需要区分nodetype，因为vue 的模板或者是指令都是自己定义好的，如v-text双大括号这些，然后和dep里的收集做一个匹配，render到我们indec.html定义的app里去。
总结一下就是收集数据依赖，然后装到订阅器里，匹配dom中的指令，进行赋值。这是双向绑定。

然后每次修改数据呢？会有一个dom diff的过程。当我们第一次渲染dom的时候，会把dom转成一个vdom对象，是个js对象。当修改数据的时候，会走vue的update钩子，首先通过拿到修改后的数据依赖，生成一份新的vdom对象，和旧的vdom比较，比较是一个逐层比较的过程，走patch方法，相同不管，不同直接新生成一个，把旧的移除，把新的放进去。然后去比较下一层，会有一个updatechildren的过程。children可能会是多个，所以我们给每个孩子定义索引，新旧比较，相同不管，不同新的孩子插入到旧孩子前一个索引下标处，旧孩子移除。前面比较的同时后面也开始比较，一直到startindex大于等于endindex表示比较完了。
然后我们就知道哪里变了，只把变了的vdom render成真正的dom就可以了。

为什么要搞这么复杂呢？原来jq时代也没看出啥问题啊，非说影响效率了。
浏览器渲染呢，先从定义的doctype知道浏览器用哪种格式编译文档，然后把我们写的html语义化标签编译成一个dom树 然后再拿到css组成样式树，这样就可以计算一些宽高，距离，定义一些颜色，最后由上到下渲染我们的html内容。所以老说少用table iframe由于之前jq最爱操作dom，每次js操作dom都会有一个连桥的过程，会影响性能，每次操作dom都需要访问dom又影响性能，dom改变了浏览器直接回流，就是页面再从body从上到下render一遍，如果修改一些宽高样式，还会完成页面重绘，所以就要搞虚拟dom了呗。



为什么vue2不对数组进行Object.defineProperty。

https://www.cnblogs.com/youhong/p/12173354.html
https://www.jb51.net/article/171869.htm 