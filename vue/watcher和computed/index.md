应用场景
watcher: 当一个数据影响多个数据的时候，一对多
         比如在搜索数据的时候
computed ： 当一个数据收多个数据影响的时候
        购物车商品结算的时候
区别：
    watch:  监听属性的变化
            1、不支持缓存，数据变化直接操作相应的操作
           2、支持异步
           3、接受两个参数一个新的一个旧的
           4、监听的数据必须是data中声明的过的或者父组件传过来的props中的属性
              deep深度监听：为了监听对象内部的变化，复杂类型数据时使用。但是watch的深度监听无法监听数组的变化和对象的新增，只有以响应式方式触发才可以被监听到。
              
              （就像操作数组的方法 ：push，pop,shift, unshift,splice, sort, reverse,当使用这些方法操作数组的时候，才可以使得watch监听到数组的变化，因为vue的源码中，将这些方法重写了，对数组的原生的方法进行了变异）
              
             ps:而 无法监听到对象的新增是因为vue通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，而settet/getter只能追踪一个数据被改，而不能够追踪新增或者删除的属性。要使得watch可以监听对象的增加或者删除变化，就可以使用：
                    删除对象属性：使用vm.$delete实现
                    新增对象属性：使用使用Vue.set(obj, a,b)方法向嵌套对象添加响应式属性。

    computed： 通过计算属性得出结果
               1、只有依赖的数据发生变化的时候才重新计算
               2、不支持异步，当computed里面异步操作再里面就无法监听数据。
               3、计算结果会被缓存，除非所以依赖的属性发生变化的时候，才会重新计算

    所以，当 在数据变化执行异步操作或者有开销较大的操作的时候，就使用watch。
    当对于任何复杂逻辑或者一个属性所以依赖的属性发生变化的时候，他本身也要发生变化，那么就最好使用这计算属属性。