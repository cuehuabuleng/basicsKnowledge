# 浏览器输入url后发生了什么

## 网络请求

### 1、输入地址

### 2、浏览器查找域名的IP地址
&emsp;&emsp; 输入的是域名的话，那就要通过域名去获取对应的ip地址，需要依赖一个服务系统叫**DNS域名解析**。从查找到获取到具体IP的过程叫做**DNS解析。** 浏览器提供了DNS数据缓存功能，浏览器会将解析过的域名进行缓存。解析的过程如下:

* 1、首先 ,浏览器查看是否有对应的域名缓存，有的话直接用缓存的ip访问,如果浏览器中没有缓存，那就在本地的host文件 （一般在c盘里面）中查找。
 * 2、如果host文件里面没有找到想要解析的域名的话，那就将域名发送到自己本地的dns服务器上面，查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归**的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
 * 3、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是**迭代**的过程。全球根服务器一共13台，发送到其中一台，进行域名查找。会逐级的从顶级域名一直往下查找，知道找到最精确的那一台域名服务器，进行解析，返回结果到浏览器，至此域名解析完。
 * 4、 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

### 3、建立TCP连接
&emsp;&emsp; 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

> 同一个域名下只能有6个TCP连接，超过六个之后，其他的请求就得等待。
        tcp建立连接分以下三个阶段：
>* 1、通过三次握手，简建立服务端和客户端的连接
>* 2、进行数据的传输
>* 3、断开连接，数据传输完成之后，通过四次挥手来进行断开连接。

**&emsp;&emsp; 从上面看得出来，TCP 连接通过什么手段来保证数据传输的可靠性，一是三次握手确认连接，二是数据包校验保证数据到达接收方，三是通过四次挥手断开连接。**

### 4、发送http请求
&emsp; &emsp;TCP连接完成后，接下来就可以与服务器通信了，也就是我们经常说的发送HTTP请求。
发送HTTP请求的话，需要携带三样东西：「请求行」，「请求头」，「请求体」。如下：
```http
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: juejin.im
Pragma: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36
```
&emsp;&emsp;HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是通常我们说的返回网络响应。跟请求部分类似，网络响应具有三个部分:「响应行」、「响应头」和「响应体」。如下：
```http
<!-- 响应行 -->
HTTP/1.1 200 OK
<!-- 响应头 -->
Access-Control-Max-Age: 86400
Cache-control: private
Connection: close
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 22 Jul 2020 13:24:49 GMT
Vary: Accept-Encoding
Set-Cookie: ab={}; path=/; expires=Thu, 22 Jul 2021 13:24:49 GMT; secure; httponly
Transfer-Encoding: chunked
```
&emsp;&emsp;在浏览器拿到数据之后，是否会断开连接，就取决于响应头中的Connection字段。
> 上面的字段值为close，那么就会断开，一般情况下，HTTP1.1版本的话，通常请求头会包含「Connection: Keep-Alive」表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。

网络请求-响应阶段结束之后，接下来就是浏览器页面萱渲染阶段。

## 渲染阶段
&emsp;&emsp;在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括： 
### 1、构建DOM TREE dom树
* 遍历html文档节点，生成与html标签一一对应的DOM树。
*  DOM树的渲染过程可能会被css或者js的加载阻塞
* display:none 的元素， 注释，script标签也会在DOM树中
### 2、CSS解析，构建css规则树
### 3、构建渲染树 Render tree
* 通过css规则树和DOM树来构建渲染树
### 4、 渲染树布局  render tree layout
&emsp;&emsp; 布局阶段浏览器会从树的根节点开始遍历每一个节点，每一个节点都是一个Render Object对象，里面有宽高、位置、颜色等样式信息。浏览器通过这些信息来知道每一个节点在页面上的位置。然后这一步结束之后就会输出一个盒子模型。
### 5、渲染树绘制
&emsp;&emsp;浏览器的渲染阶段，浏览器会遍历树，然后调用渲染器的paint()方法，在屏幕上显示其内容。

![WebKit渲染的过程](./01.png)

### 关于一些页面资源加载解析阻塞的问题探讨
>&emsp;&emsp;浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。
>
>&emsp;&emsp;解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。
>
>&emsp;&emsp;DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。
>
>&emsp;&emsp;页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。


>&emsp;&emsp;当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。
>
>&emsp;&emsp;JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。
>
>&emsp;&emsp;JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。

       

