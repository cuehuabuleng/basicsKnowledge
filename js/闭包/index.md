什么是闭包：
    闭包是有权访问另一个函数作用域的变量的函数。
    简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。


作用就是：
    读取及操作外部函数的私有变量。
    使得外部函数的私有变量不会被清除，一直存在内存中。


    .避免全局污染
    .缓存数据


应用场景：

闭包隐藏数据，只提供API给外部使用。

定时器


闭包中的变量：
    例子：
1、

    ```javascript
    // 函数作为值返回
        function create () {
            let a = 100;
            return function () {
                console.log(a)
            }
        }
        let fn = create();
        let a = 200;
        fn();  //100

    // 函数作为参数被传递
        function print () {
            let a = 200;
            fn()
        }
        let a = 100;
        function fn () {
            console.log(a)
        }
        print(a) //100
    ```
    闭包中的变量查找是在函数定义的地方，向上上级作用域查找，不是在函数执行的地方。
    

    2、

    ```javascript
     function fn(){
            var i = 1;
            return function(){
                return i ++
            }
        }
        console.log(fn()) //ƒ (){return i ++}
        console.log(fn()())  //1
        console.log(fn()()) //1
        // 上面每执行一次，就会形成一个新的环境，这个环境就是闭包环境。所以就会每次都会输出=>  1



        // 声明一个全局变量，来接受父函数执行后返回的匿名函数，此时test也就是一个函数了。

        // 上面将讲fn函数每执行一次，都会形成一个新的环境，这个新的环境被全局变量test保存下来，
        // test和子函数建立引用关系，子函数和父函数中的局部变量有事存在着引用关系
        // 而上面说两个以上存在引用关系的对象，只要有一个是全局的，那么其他的就不会被回收。
        var test = fn();
        console.log(test) //ƒ (){return i ++}
        console.log(test()) //1
        console.log(test()) //2

        //因为fn没执行一次就会生成一个新的环境， 这个环境就成为闭包。所以这个test2对上面的那个test没有任何影响。
        var test2 = fn();
        console.log(test2)  //ƒ (){return i ++}
        console.log(test2())  //1
        console.log(test2())   //2
    ```


3、关于闭包的问题

```javascript
        let a = 0,
            b = 0;
            function A(a){
                A = function (b) {
                    console.log('a + b',a + b ++)
                }
                console.log('a', a++)
            }
            A(1)  //1    
            // 第一次执行A函数的时候，向里面传进了一个参数a = 1，然后A函数里面代码就开始执行， 首先会将A 等于一个函数 fucntion(){...}， 然后就console.log(a)输出  ‘a’ 1

            A(2)  //4

            // 第二次执行A函数的时候，此时的A已经是指向了另外的一个地址了，不再是原来的那个A函数了，然后此时这A函数就会接受一个b=2的参数，然后执行里面的代码 'console.log("a+b",a+b++)'，这时候的a已经是等于2了，因为上次传进来的a是1，然后上次执行完之后，就a++，所以，a=2.输出4.其实主要就是上次执行完A函数之后，又将A重新赋值指向另外一个函数，其实这里的A是全局的变量，所有，执行完上次的函数A之后，那个传进来的a并不会被销毁，因为这时候，已经产生了一个闭包，就是第二个函数，这个函数里面还引用到了a，所以这时候的a的值是上一次函数执行完之后的值。

```