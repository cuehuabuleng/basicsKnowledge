一、内存泄漏
 js有个垃圾回收机制，当某个内存中的值被引用为零时，就会将其回收。但是当变量已经使用完毕了，但是还是被引用，导致垃圾回收机制无法回收这就造成了内存泄漏。传统的页面每次跳转的时候都会释放内存，所以并不是很明显。但是单页面比如像vue，页面是通过路由跳转，不会刷新页面，会导致内存泄漏不断堆积，导致页面卡顿。

    常见的内存泄漏现象：
    1、意外的全局变量：当在js的非严格模式中，未经定义的变量直接使用，会挂在到window上面，就会永久的保存在内存中。
      解决：使用js严格模式。
    2、计时器或者回调函数忘记处理：比如一个定时器 setINterval使用了之后，没有销毁，一个变量在计时器的回调函数中使用，但是整个回调函数实没有被销毁的，这时候变量或者函数实无法被回收的。
        解决：需要手动去销毁，在页面跳转之前，调用生命周期钩子或者其其他办法去销毁。
    3、脱离DOM的引用：将需要操作的DOM元素，存放在了一个json对象里面，方便操作。此时同样的DOM元素就会有两个引用了。一个在DOM树中，另外一个在json对象中。在删除dom的时候，需要两个引用都删除。
    4、闭包： 

  变量的生命周期
当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。


可达性 :j avaScript 中内存管理的主要概念是可达性。 简单来说，“可达性”就是那些以某种方式可访问或者可用的值，他们被保证储存在内存中。

二、垃圾回收机制
    js引擎的一个后台进程-垃圾回收器，监视所有对象，并删除不可访问的对象。
    
    JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
    
    
    1、基本内部算法：的垃圾回收算法：标记-清除算法  ，定期执行以下步骤：
    js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为"进入环境"，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为"离开环境"。

    ```javascript
        function test(){
            var a = 10;    //被标记"进入环境"
            var b = "hello";    //被标记"进入环境"
        }
        test();    //执行完毕后之后，a和b又被标记"离开环境"，被回收
    ```
        JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

        可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后还有标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

        标记清除的算法，具体是怎么样的呢，看下面：（其实就是根据可达性的这一规则，进行标记和清除  可达性其实就是一种js的内存管理的概念：https://segmentfault.com/a/1190000018605776）
          
        垃圾收集器扎根并“标记”（记住）它们。
        然后，它访问并“标记”来自它们的所有引用。
        然后，它访问标记的对象并标记其引用。记住所有访问过的对象，以免将来再次访问同一对象。
        …依此类推，直到访问了所有可到达的引用（从根开始）。
        除标记对象外的所有对象均被删除。
        就是先标记根，然后标记根的引用，然后再往下找引用的引用，一层层往找、标记，知道找不到引用为止。然后对那些没有标记的引用进行删除。






    2、引用计数
        这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。 但是该方法会引起内存泄漏是因为他不能够解决循环引用问题。

        还有其他的算法：https://www.jianshu.com/p/a8a04fd00c3c

   